var geoApp = angular.module('toxic.geotracker', ['ionic', 'starter.controllers', 'ngCordova', 'pascalprecht.translate'])

        .run(['$ionicPlatform', '$rootScope', '$timeout', '$translate', 'SettingsService', function ($ionicPlatform, $rootScope, $timeout, $translate, SettingsService) {
            $ionicPlatform.ready(function () {
                // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
                // for form inputs)
                if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
                    cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
                    cordova.plugins.Keyboard.disableScroll(true);

                }
                if (window.StatusBar) {
                    // org.apache.cordova.statusbar required
                    StatusBar.styleDefault();
                }

                $rootScope.apikey = SettingsService.get().apikey;

                $rootScope.$on('locale-changed', function(event, locale){
                    $translate.use(locale.id);
                });

                // Find matches
                var mql = window.matchMedia("(orientation: portrait)");

                // If there are matches, we're in portrait
                if (mql.matches) {
                    // Portrait orientation
                } else {
                    // Landscape orientation
                }

                // Add a media query change listener
                mql.addListener(function (m) {
                    if (m.matches) {
                        /**
                         * Changed to portrait
                         * 
                         * This is the app default orientation. Google Map should 
                         * be displayed with its initial height.
                         */
                        $timeout(function () {
                            angular.element(document.getElementById('map')).css('height', 'initial');
                            google.maps.event.trigger($rootScope.map, 'resize');
                        });
                    } else {
                        /**
                         * Changed to landscape
                         * 
                         * Change Google Map container height by using the device 
                         * screen height and mapScreenScale, which is defined on 
                         * per controller basis. 
                         */
                        $timeout(function () {
                            angular.element(document.getElementById('map')).css('height', (screen.height * $rootScope.mapScreenScale) + 'px');
                            google.maps.event.trigger($rootScope.map, 'resize');
                        });
                    }
                });
            });
        }])
        .provider('settingsService', function settingsServiceProvider() {
            this.$get = function() {
                return new SettingsService();
            };            
            return this;
        })
        .config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {
            $stateProvider

                    .state('app', {
                        url: '/app',
                        abstract: true,
                        templateUrl: 'templates/menu.html',
                        controller: 'AppCtrl'
                    })

                    .state('app.track', {
                        url: '/track',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track.html',
                                controller: 'TrackController'
                            }
                        }
                    })

                    .state('app.history', {
                        url: '/history',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/history.html',
                                controller: 'HistoryController'
                            }
                        }
                    })

                    .state('app.trackview', {
                        url: '/track/:trackId',
                        cache: false,
                        resolve: {
                            track: ['$stateParams', 'TrackStorage', function ($stateParams, TrackStorage) {
                                return TrackStorage.getById($stateParams.trackId);
                            }]
                        },
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track-view.html',
                                controller: 'TrackViewController'
                            }
                        }
                    })

                    .state('app.trackedit', {
                        url: '/track/edit/:trackId',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track-edit.html',
                                controller: 'TrackEditController'
                            }
                        }
                    })

                    .state('app.settings', {
                        url: '/settings',
                        cache: false,
                        resolve: {
                            mapTypes: ['SettingsService', function (SettingsService) {
                                return SettingsService.getMapTypes();
                            }],
                            availableLanguages: ['I18nService', function (I18nService) {
                                return I18nService.getAvailableLanguages();
                            }],
                            settings: ['SettingsService', function (SettingsService) {
                                return SettingsService.get();
                            }]
                        },
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/settings.html',
                                controller: 'SettingsController'
                            }
                        }
                    });

            // if none of the above states are matched, use this as the fallback
            $urlRouterProvider.otherwise('/app/track');
        }])

        .config(['$translateProvider', function ($translateProvider) {
            $translateProvider.translations('en', TRANSLATIONS.en);
            $translateProvider.translations('bg', TRANSLATIONS.bg);

            $translateProvider.useSanitizeValueStrategy('escape');
            
            //we are not able to use the SettingsService at this point
            //hint: custom SettingsService provider?
            var settings = JSON.parse(localStorage.getItem('settings'));
            
            var locale = (!_.isEmpty(settings)) ? settings.locale : config.defaults.locale
            
            $translateProvider.preferredLanguage(locale.id);
        }])
        .filter('mapsUrl', ['$sce', function ($sce) {
            return function (apikey) {
                if (_.isEmpty(apikey)) {
                    return $sce.trustAsResourceUrl(config.maps.js);
                } else {
                    return $sce.trustAsResourceUrl(config.maps.js + '?key=' + apikey);
                }
            };
        }]);

var ctrl = angular.module('starter.controllers', []);
config = {
    maps: {
        js: 'https://maps.googleapis.com/maps/api/js',
        types: {
            js: 'settings.map.type.js',
            native: 'settings.map.type.native',
        }
    },
    defaults: {
      locale: {
          id: 'en',
          name: 'English'
      },
      mapType: 'js',
      apikey : 'AIzaSyAFqZ9Fs3e9PK0YpfOom-Ewi_gh4qV0eqc'
    }
};
var TRANSLATIONS = {
    "en": {
        "name" : "English",
        
        "nav.menu": "Menu",
        "nav.home": "Home",
        "nav.history": "History",
        "nav.settings" : "Settings",
        "nav.edit" : "Edit",
        
        "track.start": "Start new track",
        "track.stop": "Stop",
        "track.save": "Save",
        "track.title" : "Track title",
        "track.notes" : "Track notes",
        "track.point_no": "Point #{{ id }}",
        "track.longitude": "Longitude",
        "track.latitude": "Latitude",
        "track.altitude": "Altitude",
        "track.direction": "Heading",
        "track.speed": "Speed",
        "track.details": "Details",
        "track.delete" : "Delete",
        "track.edit" : "Edit",
        "track.startTime" : "Start",
        "track.endTime" : "End",
        "track.duration" : "Duration",
        
        
        "settings.language" : "Language",
        "settings.maptypes" : "Map type",
        "settings.map.type.js" : "JavaScript",
        "settings.map.type.native" : "Native",
        "settings.apikey" : "Google API Key",
        
        "dialog.confirm" : "Confirm",
        "dialog.track.confirm" : "Are you sure you want to delete this track?",
        
        "common.yes" : "Yes",
        "common.no" : "No",
        "common.cancel" : "Cancel",
        
        "time.year" : "year(s)",
        "time.month" : "month(s)",
        "time.day" : "day(s)",
        "time.hour" : "hour(s)",
        "time.minute" : "minute(s)",
        "time.second" : "second(s)"
    },
    "bg": {
        "name" : "Български",
        
        "nav.menu": "Меню",
        "nav.home": "Начало",
        "nav.history": "История",
        "nav.settings" : "Настройки",
        "nav.edit" : "Редактирай",
        "track.startTime" : "Начало",
        "track.endTime" : "Край",
        "track.duration" : "Време",
        
        "track.start": "Нов маршрут",
        "track.stop": "Стоп",
        "track.save": "Запази",
        "track.title" : "Име на маршрута",
        "track.notes" : "Бележки",        
        "track.point_no": "Точка №{{ id }}",
        "track.longitude": "Геогр. дълж.",
        "track.latitude": "Геогр. шир.",
        "track.altitude": "Надм. вис.",
        "track.direction": "Посока",
        "track.speed": "Скорост",
        "track.details": "Детайли",
        "track.delete" : "Изтрий",
        "track.edit" : "Редактирай",
        
        "settings.language" : "Език",
        "settings.maptypes" : "Тип карти",
        "settings.map.type.js" : "JavaScript",
        "settings.map.type.native" : "Native",        
        "settings.apikey" : "Google API Key",
        
        "dialog.confirm" : "Потвърди",
        "dialog.track.confirm" : "Наистина ли искате да изтриете този запис?",
        
        "common.yes" : "Да",
        "common.no" : "Не",
        "common.cancel" : "Откажи",
        
        "time.year" : "г.",
        "time.month" : "мес.",
        "time.day" : "дн.",
        "time.hour" : "ч.",
        "time.minute" : "мин.",
        "time.second" : "сек."
    }
};
ctrl.controller('AppCtrl', function () {});
ctrl.controller('SettingsController', ['$rootScope', '$scope', 'mapTypes', 'availableLanguages', 'settings', 'SettingsService', function ($rootScope, $scope, mapTypes, availableLanguages, settings, SettingsService) {

    //options for map type dropdown
    $scope.mapTypes = mapTypes;
    
    //options for languages dropdown
    $scope.availableLanguages = availableLanguages;
    
    //make the settings available in the view
    $scope.settings = settings;

    /**
     * If the locale change, emit an event and pass the data, so the app interface 
     * can be translated immediately. There is a listener in the .run() method.
     */
    $scope.$watch('settings.locale', function(newLocale){
        $rootScope.$emit('locale-changed', newLocale);
    });

    //Settings will be updated onblur or on page leave (which is blur again)
    $scope.$watch('settings', function(newSettings){
        SettingsService.set(newSettings);
    }, true);

}]);
geoApp.service('I18nService', ['$translate', function ($translate) {

    this.getAvailableLanguages = function () {

        var availableLanguages = [];

        //get available languages
        angular.forEach(TRANSLATIONS, function (keys, id) {
            availableLanguages.push({
                id: id,
                name: keys.name
            });
        });

        return availableLanguages;

    };

    this.setPreferedLanguage = function (selectedLanguage) {
        localStorage.setItem("locale", JSON.stringify(selectedLanguage));
        $translate.use(selectedLanguage.id)
    }

}])
geoApp.factory('JsMapsService', ['$rootScope', '$q', '$timeout', function ($rootScope, $q, $timeout) {

    var ms = {};

    ms.initMap = function (selector) {

        var deferred = $q.defer();

        var mapOptions = {
            zoom: 15,
            mapTypeId: google.maps.MapTypeId.ROADMAP
        };

        $timeout(function () {
            deferred.resolve(
                    new google.maps.Map(document.getElementById(selector), mapOptions)
                    );
        });

        return deferred.promise;
    };


    // Function that return a LatLng Object to Map
    ms.setPosition = function (lat, lng) {
        return new google.maps.LatLng(lat, lng);
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps 
     * 
     * Use this method when the app is compiled with the native maps plugin. 
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ms.getPolylinePoints = function (points) {

        var filtered = [];

        angular.forEach(points, function (point) {
            this.push(ms.setPosition(point.coords.latitude, point.coords.longitude));
        }, filtered);

        return filtered;
    };

    ms.addMarker = function (map, point) {
        var marker = new google.maps.Marker({
            position: point
        });

        marker.setMap(map);
        map.setCenter(marker.getPosition());

        return map;
    };

    /**
     * Removes a map from DOM
     */
    ms.remove = function (map, selector) {
        //Find the map DOM element
        var mapElement = document.getElementById(selector);

        //remove the html code
        mapElement.innerHTML = '';

        //remove the inline style
        mapElement.removeAttribute("style");

        //reset our internal map reference
        map = null;

        return map;
    }


    return ms;

}]);
geoApp.factory('NativeMapsService', ['$rootScope', '$q', function ($rootScope, $q) {

    var ms = {};

    ms.initMap = function (selector, cameraOptions) {

        var deferred = $q.defer();

        // Getting the map selector in DOM
        var map_container = document.getElementById(selector);

        if (!_.isUndefined(cameraOptions.point) && !_.isUndefined(cameraOptions.point.latitude) && !_.isUndefined(cameraOptions.point.longitude)) {
            cameraOptions.latLng = ms.setPosition(cameraOptions.point.latitude, cameraOptions.point.longitude);
            delete cameraOptions.point;
        }

        if (_.isUndefined(cameraOptions.zoom)) {
            cameraOptions.zoom = 10;
        }

        // Invoking Map using Google Map SDK v2 by dubcanada
        var map = plugin.google.maps.Map.getMap(map_container, {
            camera: cameraOptions
        });

        //@see MenuController
        $rootScope.$on('sidemenu:on', function () {
            map.setClickable(false);
        });

        //@see MenuController
        $rootScope.$on('sidemenu:off', function () {
            map.setClickable(true);
        });

        // Capturing event when Map load are ready.
        map.addEventListener(plugin.google.maps.event.MAP_READY, function (map) {
            deferred.resolve(map);
        });
        
         return deferred.promise;
    };


    // Function that return a LatLng Object to Map
    ms.setPosition = function (lat, lng) {
        return new plugin.google.maps.LatLng(lat, lng);
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps 
     * 
     * Use this method when the app is compiled with the native maps plugin. 
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ms.getPolylinePoints = function(points){

        var filtered = [];
        
        angular.forEach(points, function(point){
            this.push(ms.setPosition(point.coords.latitude, point.coords.longitude));
        }, filtered);

        return filtered;
    }


    return ms;

}]);
geoApp.service('SettingsService', ['$translate', 'I18nService', function ($translate, I18nService) {

    /**
     * Get app settings
     * 
     * If there are no settings in the local storage (e.g. the app is started 
     * for the first time), set the default settings and make them available.
     * 
     * @returns {object}
     */
    this.get = function () {
        
        var settings = JSON.parse(localStorage.getItem('settings'));

        if(_.isEmpty(settings)){
            settings = this.setDefaults();
        }
        
        return settings;
    };

    /**
     * Set/updates the app settings
     * 
     * @param {object} data Empty properties will be skipped
     */
    this.set = function (data) {
        var data = _.omitBy(data, function (value) {
            return _.isEmpty(value);
        });

        localStorage.setItem("settings", JSON.stringify(data));
    }

    /**
     * Set default app settings
     * 
     * @returns {settings_L1.setDefaults.defaults}
     */
    this.setDefaults = function () {

        var defaults = {
            locale: config.defaults.locale,
            mapType: _.filter(this.getMapTypes(), {id: config.defaults.mapType}).shift(),
            apikey: config.defaults.apikey
        };

        this.set(defaults);
        
        return defaults;
    }

    /**
     * Map types
     * 
     * Retrives an array of the available map types in config.json file. It will 
     * be presented in the app settings to define which map type to be in used - 
     * Javascript or native.
     * 
     * @returns {Array}
     */
    this.getMapTypes = function () {

        var mapTypes = [];

        angular.forEach(config.maps.types, function (name, id) {

            this.push({
                id: id,
                name: $translate.instant(name)
            });
        }, mapTypes);

        return mapTypes;

    };

}]);
geoApp.factory('TrackStorage', ['$translate', function ($translate) {

    /**
     * Key name to store the tracks under in localStorage
     * @type String
     */
    var key = 'tracks';

    /**
     * Service object
     * 
     * The service object holds all the public methods
     * 
     * @type object
     */
    var ts = {};

    /**
     * Get all the tracks
     * 
     * @returns {Array} In  case there are no tracks, an empty array will be returned
     */
    ts.getAll = function () {

        var serializedTracks = _get();

        return (_.isNull(serializedTracks)) ? [] : JSON.parse(serializedTracks);
    };

    /**
     * Get a track by id
     * 
     * @param {integer} id
     * @returns {object}
     */
    ts.getById = function (id) {
        return _.find(ts.getAll(), {trackId: parseInt(id)});
    };

    /**
     * Save track
     * 
     * Add a new track or update an existing one. 
     * 
     * If there are no tracks in the storage (this is the first one), add the new 
     * track to the empty tracks array. 
     * 
     * In case there are some tracks in the storage, try to lookup the track by 
     * its trackId property. If the passed track object does not exists in the 
     * tracks array, add the new one at the end. If the passed track object does 
     * exists at the tracks array, find its index and replace the value.
     * 
     * If the index parameter was set, we will replace the track object under 
     * that index.
     * 
     * @param {object} track Track object to save
     * @param {Integer|undefined} idx Index to update
     */
    ts.save = function (track) {

        var tracks = ts.getAll();

        var query = {trackId: track.trackId};

        var isExisting = (_.find(tracks, query)) ? true : false;

        if (_.isEmpty(tracks)) {
            tracks.push(track);
        } else if (!_.isEmpty(tracks) && !isExisting) {
            tracks.push(track);
        } else if (!_.isEmpty(tracks) && isExisting) {

            var idx = _.findIndex(tracks, query);

            tracks[idx] = track;
        }

        _set(tracks);
    };

    /**
     * Delete the selected track
     * 
     * Get all tracks and identify the one to be deleted by the trackId property, 
     * then update the storage.
     * 
     * @param {object} track
     */
    ts.delete = function (track) {

        var tracks = ts.getAll();

        _.remove(tracks, function (t) {
            return t.trackId === track.trackId;
        });

        _set(tracks);
    };

    ts.formatDuration = function (duration) {
        return moment.duration(duration, "seconds")
                .format("Y [" + $translate.instant('time.year') + "], M [" + $translate.instant('time.month') + "], D [" + $translate.instant('time.day') + "], h [" + $translate.instant('time.hour') + "], m [" + $translate.instant('time.minute') + "], s [" + $translate.instant('time.second') + "]");
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps for Polyline
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ts.getPolylinePoints = function(points){

        var filtered = [];
        
        angular.forEach(points, function(point){
            this.push({lat: point.coords.latitude, lng: point.coords.longitude});
        }, filtered);

        return filtered;
    }

    /**
     * Write to local storage
     * 
     * Private method to write data to the local storage under the service key.
     * 
     * @param {object} value Object to be serialized and written as JSON string
     */
    var _set = function (value) {
        localStorage.setItem(key, JSON.stringify(value));
    };

    /**
     * Read from local storage
     * 
     * Read the data from local storage under the service key
     * 
     * @returns {DOMString}
     */
    var _get = function () {
        return localStorage.getItem(key);
    };

    return ts;

}]);
ctrl.controller('TrackEditController', ['$scope', '$state', '$stateParams', 'TrackStorage', function ($scope, $state, $stateParams, TrackStorage) {

    $scope.track = TrackStorage.getById($stateParams.trackId);

    $scope.updateTrack = function () {
        TrackStorage.save($scope.track);
        $state.go('app.trackview', $stateParams);
    }

}]);
ctrl.controller('HistoryController', ['$scope', 'TrackStorage', function ($scope, TrackStorage) {
    $scope.items = TrackStorage.getAll();
}]);
ctrl.controller('TrackController', ['$rootScope', '$scope', '$state', '$ionicLoading', '$cordovaGeolocation', '$translate', '$timeout', 'JsMapsService', 'TrackStorage', 'SettingsService', function ($rootScope, $scope, $state, $ionicLoading, $cordovaGeolocation, $translate, $timeout, JsMapsService, TrackStorage, SettingsService) {

    $scope.jsMapSelector = 'js_map';
    $scope.nativeMapSelector = 'native_map';

    //has tracking been started or not
    $scope.isTracking = false;
    $scope.readyToSave = false;
    $scope.initPoint = {};

    //map scale ratio, see app.js
    $rootScope.mapScreenScale = 0.8;

    /**
     * Start a new track
     * 
     * When the "Start" button is clicked, we will first try to get the current 
     * position and in case of success, will broadcast the "tracking:started" 
     * event along with the location data.
     * 
     * @todo In case of an error, show a proper message.
     * @returns {undefined}
     */
    $scope.startTracking = function () {

        $scope.startTime = new Date();

        $ionicLoading.show();

        $cordovaGeolocation.getCurrentPosition({
            timeout: 30000,
            enableHighAccuracy: false,
            maximumAge: 2000
        }).then(function (locationData) {
            $scope.$broadcast('tracking:started', locationData);
        }, $scope.positionError)
                .finally(function () {
                    $ionicLoading.hide();
                });
    }

    /**
     * Track success callback
     * 
     * Will be called on position change. Actions to be performed: 
     * 1. Collect the position data
     * 2. Call the watchTracking function, if the watcher hasn't been started yet.
     * 3. Call the updateMap function to add a new marker.
     * 
     * @param {object} data
     * @returns {undefined} Object with two keys - timestamp and coords. Coords 
     * itself is an object with two keys - latitiude and longitude. 
     * 
     * @example 
     * {
     *  timestamp: data.timestamp,
     *  coords: {
     *      latitude: data.coords.latitude,
     *      longitude: data.coords.longitude
     *  }
     * }
     */
    $scope.positionSuccess = function (data) {
console.log("positionSuccess", data)
        //add the new point to the array of points
        $scope.points.push(data);

        //if watcher hasn't been started yet, start it now
        if (!$scope.trackWatch) {
            $scope.watchTracking();
        }

        //show position on the map
        $scope.updateMap(data.coords.latitude, data.coords.longitude);
    }

    //error callback
    $scope.positionError = function (error) {
        console.log("error", error)
    }

    /**
     * Position change track
     * 
     * Will track new position change every 3 seconds
     * 
     * @returns {undefined}
     */
    $scope.watchTracking = function () {
console.log('call watchTracking')
        $scope.trackWatch = $cordovaGeolocation.watchPosition({
            timeout: 30000,
            frequency: 2000,
            enableHighAccuracy: false // may cause errors if true
        });

        $scope.trackWatch.then(null, function (error) {
console.log("error")
            $scope.positionError(error);

            //restarting the watcher
            $scope.trackWatch.clearWatch();
            $scope.watchTracking();

        }, function(data){
            console.log('success', data)
            $scope.positionSuccess(data);
        });

    }

    //display position on the map
    $scope.updateMap = function (latitude, longitude) {
console.log("updateMap", latitude, longitude)        
        $scope.map = JsMapsService.addMarker(
                $scope.map,
                JsMapsService.setPosition(latitude, longitude)
        );
console.log("map", $scope.map)
    }

    /**
     * Stop tracking
     * 
     * 1. Save the current track in the history
     * 2. Stop the watcher
     * 3. Clear the points array
     * 
     * @returns {undefined}
     */
    $scope.stopTracking = function () {
        $scope.endTime = new Date();
        $scope.isTracking = false;
        $scope.trackWatch.clearWatch();

        $scope.$broadcast('tracking:stopped');
    }

    /**
     * Save the current track to the app history
     * 
     * We will call it from the view.
     * 
     * @returns {undefined}
     */
    $scope.saveHistory = function () {

        var track = {
            trackId: $scope.trackId,
            points: $scope.points,
            info: _.omitBy($scope.trackInfo, function (value) {
                return _.isEmpty(value);
            }),
            startTime: $scope.startTime,
            endTime: $scope.endTime,
            duration: moment($scope.endTime).diff(moment($scope.startTime), "seconds")
        };

        TrackStorage.save(track);

        $scope.$broadcast('tracking:saved');
    }

    /**
     * Listener for the tracking:started event
     * 
     * When this event is captured, it means the tracking has been started 
     * successfully and we have the current position. Actions to be performed: 
     * 1. Call the MapService to initialize the map. 
     * 2. Set the initial states of all supporting variables. 
     * 3. Call the positionSuccess function.
     */
    $scope.$on('tracking:started', function (event, data) {

        $scope.initPoint = data;

        JsMapsService.initMap($scope.jsMapSelector, {
            point: $scope.initPoint.coords,
            zoom: 16
        }).then(function (map) {

            $scope.map = map;

            $scope.isTracking = true;

            //container for geo location points
            $scope.points = [];

            //has watcher been started or not
            $scope.trackWatch = null;

            $scope.trackId = (new Date()).getTime();

            $scope.trackInfo = {
                title: null,
                notes: null
            };

            $scope.positionSuccess($scope.initPoint);

            $scope.initPoint = {};
        });

    });

    /**
     * Stop button listener
     * 
     * When the "Stop" button is clicked, it means the user is at their destination 
     * and are ready to save the track. Actions to be performed:
     * 
     * 1. Hide the start/stop buttons at the top.
     * 2. Allow the user to optionally add title and description.
     * 3. show the save button
     * 
     * Please note, at this point the information is not saved! It's still in 
     * the current scope.
     */
    $scope.$on('tracking:stopped', function () {
        $scope.readyToSave = true;
    });

    /**
     * Save button listener
     * 
     * The track information has already been saved in the data store. Now do 
     * the chore: 
     * 1. Destroy the map
     * 2. Reset the points array to an empty one.
     * 3. Switch some flags.
     * 4. Navigate to the History page
     */
    $scope.$on('tracking:saved', function (event, data) {

        $scope.map = JsMapsService.remove($scope.map, $scope.jsMapSelector);
        
        $scope.points = [];
        $scope.readyToSave = false;

        $state.go('app.history');
    });

}]);
ctrl.controller('TrackViewController', ['$rootScope', '$scope', '$state', '$stateParams', '$ionicPopup', '$translate', '$timeout', 'TrackStorage', 'SettingsService', 'track', function ($rootScope, $scope, $state, $stateParams, $ionicPopup, $translate, $timeout, TrackStorage, SettingsService, track) {

    //track data has already been resolved in the route
    $scope.track = track;

    //human readable track duration
    $scope.formattedDuration = TrackStorage.formatDuration($scope.track.duration);

    //points list, as required by Polyline
    $scope.points = TrackStorage.getPolylinePoints($scope.track.points);

    //map scale ratio, see app.js
    $rootScope.mapScreenScale = 1;

    function initMap(points, mapTypeId) {
        $rootScope.map = new google.maps.Map(document.getElementById('map'), {
            zoom: 15,
            center: (points.length > 3) ? points[Math.ceil(points.length/2)] : points[0],
            mapTypeId: mapTypeId
        });

        // Define a symbol using SVG path notation, with an opacity of 1.
        var lineSymbol = {
            path: google.maps.SymbolPath.CIRCLE,
            strokeOpacity: 1,
            strokeWeight: 2,
            scale: 4,
            strokeColor: "#990000",
            fillColor: '#ffffff',
            fillOpacity: 1
        };

        // Create the polyline, passing the symbol in the 'icons' property.
        // Give the line an opacity of 0.
        // Repeat the symbol at intervals of 20 pixels to create the dashed effect.
        new google.maps.Polyline({
            path: points,
            strokeOpacity: 0,
            icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '20px'
                }],
            map: $rootScope.map
        });
    };

    $timeout(function(){
       initMap($scope.points, 'terrain'); 
    });
    

    //Confirmation dialog in case the user clicks on the delete button
    $scope.confirmDelete = function () {
        var confirmPopup = $ionicPopup.confirm({
            title: $translate.instant("dialog.confirm"),
            template: $translate.instant("dialog.track.confirm"),
            cancelText: $translate.instant("common.cancel"),
            cancelType: 'button-positive',
            okText: $translate.instant("common.yes"),
            okType: 'button-default'
        });

        confirmPopup.then(function (res) {
            if (res) {
                TrackStorage.delete($scope.track);
                $state.go('app.history');
            }
        });
    };
}]);