var geoApp = angular.module('toxic.geotracker', ['ionic', 'starter.controllers', 'ngCordova', 'pascalprecht.translate'])

        .run(['$ionicPlatform', '$rootScope', '$timeout', 'SettingsService', function ($ionicPlatform, $rootScope, $timeout, SettingsService) {
            $ionicPlatform.ready(function () {
                // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
                // for form inputs)
                if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
                    cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
                    cordova.plugins.Keyboard.disableScroll(true);

                }
                if (window.StatusBar) {
                    // org.apache.cordova.statusbar required
                    StatusBar.styleDefault();
                }

                $rootScope.apikey = SettingsService.get().apikey;

                // Find matches
                var mql = window.matchMedia("(orientation: portrait)");

                // If there are matches, we're in portrait
                if (mql.matches) {
                    // Portrait orientation
                } else {
                    // Landscape orientation
                }

                // Add a media query change listener
                mql.addListener(function (m) {
                    if (m.matches) {
                        /**
                         * Changed to portrait
                         * 
                         * This is the app default orientation. Google Map should 
                         * be displayed with its initial height.
                         */
                        $timeout(function () {
                            angular.element(document.getElementById('map')).css('height', 'initial');
                            google.maps.event.trigger($rootScope.map, 'resize');
                        });
                    } else {
                        /**
                         * Changed to landscape
                         * 
                         * Change Google Map container height by using the device 
                         * screen height and mapScreenScale, which is defined on 
                         * per controller basis. 
                         */
                        $timeout(function () {
                            angular.element(document.getElementById('map')).css('height', (screen.height * $rootScope.mapScreenScale) + 'px');
                            google.maps.event.trigger($rootScope.map, 'resize');
                        });
                    }
                });

            });
        }])

        .config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {
            $stateProvider

                    .state('app', {
                        url: '/app',
                        abstract: true,
                        templateUrl: 'templates/menu.html',
                        controller: 'AppCtrl'
                    })

                    .state('app.track', {
                        url: '/track',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track.html',
                                controller: 'TrackController'
                            }
                        }
                    })

                    .state('app.history', {
                        url: '/history',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/history.html',
                                controller: 'HistoryController'
                            }
                        }
                    })

                    .state('app.trackview', {
                        url: '/track/:trackId',
                        cache: false,
                        resolve: {
                            track: ['$stateParams', 'TrackStorage', function ($stateParams, TrackStorage) {
                                return TrackStorage.getById($stateParams.trackId);
                            }]
                        },
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track-view.html',
                                controller: 'TrackViewController'
                            }
                        }
                    })

                    .state('app.trackedit', {
                        url: '/track/edit/:trackId',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track-edit.html',
                                controller: 'TrackEditController'
                            }
                        }
                    })

                    .state('app.settings', {
                        url: '/settings',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/settings.html',
                                controller: 'SettingsController'
                            }
                        }
                    });

            // if none of the above states are matched, use this as the fallback
            $urlRouterProvider.otherwise('/app/track');
        }])

        .config(['$translateProvider', function ($translateProvider) {
            $translateProvider.translations('en', TRANSLATIONS.en);
            $translateProvider.translations('bg', TRANSLATIONS.bg);

            $translateProvider.useSanitizeValueStrategy('escape');

            var selectedLanguage = JSON.parse(localStorage.getItem("locale"));

            var useLanguage = (!_.isNull(selectedLanguage)) ? selectedLanguage.id : 'bg';

            $translateProvider.preferredLanguage(useLanguage);
        }])
        .filter('mapsUrl', ['$sce', function ($sce) {
            return function (apikey) {
                
                var url = 'https://maps.googleapis.com/maps/api/js';

                if(_.isUndefined(apikey)){
                    return $sce.trustAsResourceUrl(url);
                }else{
                    return $sce.trustAsResourceUrl(url + '?key=' + apikey);
                }
            };
        }]);

var ctrl = angular.module('starter.controllers', []);
var TRANSLATIONS = {
    "en": {
        "name" : "English",
        
        "nav.menu": "Menu",
        "nav.home": "Home",
        "nav.history": "History",
        "nav.settings" : "Settings",
        "nav.edit" : "Edit",
        
        "track.start": "Start new track",
        "track.stop": "Stop",
        "track.save": "Save",
        "track.title" : "Track title",
        "track.notes" : "Track notes",
        "track.point_no": "Point #{{ id }}",
        "track.longitude": "Longitude",
        "track.latitude": "Latitude",
        "track.altitude": "Altitude",
        "track.direction": "Heading",
        "track.speed": "Speed",
        "track.details": "Details",
        "track.delete" : "Delete",
        "track.edit" : "Edit",
        "track.startTime" : "Start",
        "track.endTime" : "End",
        "track.duration" : "Duration",
        
        
        "settings.language" : "Language",
        "settings.apikey" : "Google API Key",
        
        "dialog.confirm" : "Confirm",
        "dialog.track.confirm" : "Are you sure you want to delete this track?",
        
        "common.yes" : "Yes",
        "common.no" : "No",
        "common.cancel" : "Cancel",
        
        "time.year" : "year(s)",
        "time.month" : "month(s)",
        "time.day" : "day(s)",
        "time.hour" : "hour(s)",
        "time.minute" : "minute(s)",
        "time.second" : "second(s)"
    },
    "bg": {
        "name" : "Български",
        
        "nav.menu": "Меню",
        "nav.home": "Начало",
        "nav.history": "История",
        "nav.settings" : "Настройки",
        "nav.edit" : "Редактирай",
        "track.startTime" : "Начало",
        "track.endTime" : "Край",
        "track.duration" : "Време",
        
        "track.start": "Нов маршрут",
        "track.stop": "Стоп",
        "track.save": "Запази",
        "track.title" : "Име на маршрута",
        "track.notes" : "Бележки",        
        "track.point_no": "Точка №{{ id }}",
        "track.longitude": "Геогр. дълж.",
        "track.latitude": "Геогр. шир.",
        "track.altitude": "Надм. вис.",
        "track.direction": "Посока",
        "track.speed": "Скорост",
        "track.details": "Детайли",
        "track.delete" : "Изтрий",
        "track.edit" : "Редактирай",
        
        "settings.language" : "Език",
        "settings.apikey" : "Google API Key",
        
        "dialog.confirm" : "Потвърди",
        "dialog.track.confirm" : "Наистина ли искате да изтриете този запис?",
        
        "common.yes" : "Да",
        "common.no" : "Не",
        "common.cancel" : "Откажи",
        
        "time.year" : "г.",
        "time.month" : "мес.",
        "time.day" : "дн.",
        "time.hour" : "ч.",
        "time.minute" : "мин.",
        "time.second" : "сек."
    }
};
ctrl.controller('AppCtrl', function () {});
ctrl.controller('SettingsController', ['$rootScope', '$scope', '$translate', '$timeout', 'I18nService', 'SettingsService', function ($rootScope, $scope, $translate, $timeout, I18nService, SettingsService) {

    $scope.availableLanguages = I18nService.getAvailableLanguages();
    $scope.settings = SettingsService.get();

    $scope.selectedLanguage = JSON.parse(localStorage.getItem("locale"));

    $scope.setPreferedLanguage = function (selectedLanguage) {
        I18nService.setPreferedLanguage(selectedLanguage);
    }

    $scope.saveSettings = function () {
        SettingsService.set($scope.settings);
        $scope.settings = SettingsService.get();
    }

}]);
geoApp.service('I18nService', ['$translate', function ($translate) {

    this.getAvailableLanguages = function () {

        var availableLanguages = [];

        //get available languages
        angular.forEach(TRANSLATIONS, function (keys, id) {
            availableLanguages.push({
                id: id,
                name: keys.name
            });
        });

        return availableLanguages;

    };

    this.setPreferedLanguage = function (selectedLanguage) {
        localStorage.setItem("locale", JSON.stringify(selectedLanguage));
        $translate.use(selectedLanguage.id)
    }

}])
geoApp.service('SettingsService', ['$translate', function ($translate) {

    this.get = function () {
        return JSON.parse(localStorage.getItem('settings')) || {};
    };

    this.set = function (data) {
        var data = _.omitBy(data, function (value) {
            return _.isEmpty(value);
        });

        localStorage.setItem("settings", JSON.stringify(data));
    }

}]);
geoApp.factory('TrackStorage', ['$translate', function ($translate) {

    /**
     * Key name to store the tracks under in localStorage
     * @type String
     */
    var key = 'tracks';

    /**
     * Service object
     * 
     * The service object holds all the public methods
     * 
     * @type object
     */
    var ts = {};

    /**
     * Get all the tracks
     * 
     * @returns {Array} In  case there are no tracks, an empty array will be returned
     */
    ts.getAll = function () {

        var serializedTracks = _get();

        return (_.isNull(serializedTracks)) ? [] : JSON.parse(serializedTracks);
    };

    /**
     * Get a track by id
     * 
     * @param {integer} id
     * @returns {object}
     */
    ts.getById = function (id) {
        return _.find(ts.getAll(), {trackId: parseInt(id)});
    };

    /**
     * Save track
     * 
     * Add a new track or update an existing one. 
     * 
     * If there are no tracks in the storage (this is the first one), add the new 
     * track to the empty tracks array. 
     * 
     * In case there are some tracks in the storage, try to lookup the track by 
     * its trackId property. If the passed track object does not exists in the 
     * tracks array, add the new one at the end. If the passed track object does 
     * exists at the tracks array, find its index and replace the value.
     * 
     * If the index parameter was set, we will replace the track object under 
     * that index.
     * 
     * @param {object} track Track object to save
     * @param {Integer|undefined} idx Index to update
     */
    ts.save = function (track) {

        var tracks = ts.getAll();

        var query = {trackId: track.trackId};

        var isExisting = (_.find(tracks, query)) ? true : false;

        if (_.isEmpty(tracks)) {
            tracks.push(track);
        } else if (!_.isEmpty(tracks) && !isExisting) {
            tracks.push(track);
        } else if (!_.isEmpty(tracks) && isExisting) {

            var idx = _.findIndex(tracks, query);

            tracks[idx] = track;
        }

        _set(tracks);
    };

    /**
     * Delete the selected track
     * 
     * Get all tracks and identify the one to be deleted by the trackId property, 
     * then update the storage.
     * 
     * @param {object} track
     */
    ts.delete = function (track) {

        var tracks = ts.getAll();

        _.remove(tracks, function (t) {
            return t.trackId === track.trackId;
        });

        _set(tracks);
    };

    ts.formatDuration = function (duration) {
        return moment.duration(duration, "seconds")
                .format("Y [" + $translate.instant('time.year') + "], M [" + $translate.instant('time.month') + "], D [" + $translate.instant('time.day') + "], h [" + $translate.instant('time.hour') + "], m [" + $translate.instant('time.minute') + "], s [" + $translate.instant('time.second') + "]");
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps for Polyline
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ts.getPolylinePoints = function(points){

        var filtered = [];
        
        angular.forEach(points, function(point){
            this.push({lat: point.coords.latitude, lng: point.coords.longitude});
        }, filtered);

        return filtered;
    }

    /**
     * Write to local storage
     * 
     * Private method to write data to the local storage under the service key.
     * 
     * @param {object} value Object to be serialized and written as JSON string
     */
    var _set = function (value) {
        localStorage.setItem(key, JSON.stringify(value));
    };

    /**
     * Read from local storage
     * 
     * Read the data from local storage under the service key
     * 
     * @returns {DOMString}
     */
    var _get = function () {
        return localStorage.getItem(key);
    };

    return ts;

}]);
ctrl.controller('TrackEditController', ['$scope', '$state', '$stateParams', 'TrackStorage', function ($scope, $state, $stateParams, TrackStorage) {

    $scope.track = TrackStorage.getById($stateParams.trackId);

    $scope.updateTrack = function () {
        TrackStorage.save($scope.track);
        $state.go('app.trackview', $stateParams);
    }

}]);
ctrl.controller('HistoryController', ['$scope', 'TrackStorage', function ($scope, TrackStorage) {
    $scope.items = TrackStorage.getAll();
}]);
ctrl.controller('TrackController', ['$rootScope', '$scope', '$state', '$ionicLoading', '$cordovaGeolocation', '$translate', '$timeout', 'TrackStorage', 'SettingsService', function ($rootScope, $scope, $state, $ionicLoading, $cordovaGeolocation, $translate, $timeout, TrackStorage, SettingsService) {
    //has tracking been started or not
    $scope.isTracking = false;
    $scope.readyToSave = false;

    //map scale ratio, see app.js
    $rootScope.mapScreenScale = 0.8;

    //start tracking
    $scope.startTracking = function () {

        $scope.startTime = new Date();

        $ionicLoading.show();

        $cordovaGeolocation.getCurrentPosition({
            timeout: 10000,
            enableHighAccuracy: true,
            maximumAge: 3000
        }).then(function (locationData) {
            $scope.$broadcast('tracking:started');
            $scope.positionSuccess(locationData);
        }, $scope.positionError)
                .finally(function () {
                    $ionicLoading.hide();
                });
    }

    /**
     * Track success callback
     * 
     * Will be called on position change
     * 
     * @param {type} data
     * @returns {undefined}
     */
    $scope.positionSuccess = function (data) {

        //add the new point to the array of points
        $scope.points.push(data);

        /**
         * @bug Coordinates object, provided by the browsers, can not be 
         * serialized. During the development process, I can not get 
         * any coordinates into the storage.
         */
//                $scope.points.push({
//                    timestamp: data.timestamp,
//                    coords: {
//                        latitude: data.coords.latitude,
//                        longitude: data.coords.longitude
//                    }
//                });

        //if watcher hasn't been started yet, start it now
        if (!$scope.trackWatch) {
            $scope.watchTracking();
        }

        //show position on the map
        $scope.updateMap(data.coords.latitude, data.coords.longitude);
    }

    //error callback
    $scope.positionError = function (error) {
        console.log("error", error)
    }

    /**
     * Position change track
     * 
     * Will track new position change every 3 seconds
     * 
     * @returns {undefined}
     */
    $scope.watchTracking = function () {

        $scope.trackWatch = $cordovaGeolocation.watchPosition({
            timeout: 30000,
            frequency: 10000,
            enableHighAccuracy: true // may cause errors if true
        });

        $scope.trackWatch.then(null, function(error){

            $scope.positionError(error);
            
            //restarting the watcher
            $scope.trackWatch.clearWatch();
            $scope.watchTracking();
            
        }, $scope.positionSuccess);

    }

    /**
     * Initialize map
     */
    $scope.initMap = function () {

        var mapOptions = {
            zoom: 15,
            mapTypeId: google.maps.MapTypeId.ROADMAP
        };

        $timeout(function () {
            $rootScope.map = new google.maps.Map
                    (document.getElementById("map"), mapOptions);
        })

    }

    //display position on the map
    $scope.updateMap = function (latitude, longitude) {

        if (angular.isUndefined($rootScope.map)) {
            $scope.initMap();
        }

        var latLong = new google.maps.LatLng(latitude, longitude);

        var marker = new google.maps.Marker({
            position: latLong
        });

        $timeout(function () {
            marker.setMap($rootScope.map);
            $rootScope.map.setCenter(marker.getPosition());
        });
    }

    $scope.resetMap = function () {
        //Find the map DOM element
        var mapElement = document.getElementById('map');

        //remove the html code
        mapElement.innerHTML = '';

        //remove the inline style
        mapElement.removeAttribute("style");

        //reset our internal map reference
        $rootScope.map = null;
    };

    /**
     * Stop tracking
     * 
     * 1. Save the current track in the history
     * 2. Stop the watcher
     * 3. Clear the points array
     * 
     * @returns {undefined}
     */
    $scope.stopTracking = function () {
        $scope.endTime = new Date();
        $scope.isTracking = false;
        $scope.trackWatch.clearWatch();

        $scope.$broadcast('tracking:stopped');
    }

    /**
     * Save the current track to the app history
     * 
     * We will call it from the view.
     * 
     * @returns {undefined}
     */
    $scope.saveHistory = function () {

        var track = {
            trackId: $scope.trackId,
            points: $scope.points,
            info: _.omitBy($scope.trackInfo, function (value) {
                return _.isEmpty(value);
            }),
            startTime: $scope.startTime,
            endTime: $scope.endTime,
            duration: moment($scope.endTime).diff(moment($scope.startTime), "seconds")
        };

        TrackStorage.save(track);

        $scope.$broadcast('tracking:saved');
    }

    $scope.$on('tracking:started', function (event, data) {

        $scope.initMap();

        $scope.isTracking = true;

        //container for geo location points
        $scope.points = [];

        //has watcher been started or not
        $scope.trackWatch = null;

        $scope.trackId = (new Date()).getTime();

        $scope.trackInfo = {
            title: null,
            notes: null
        };
    });

    $scope.$on('tracking:stopped', function (event, data) {
        //1. allow the client to optionally add title and description

        //2. show the save button

        $scope.readyToSave = true;
    });

    $scope.$on('tracking:saved', function (event, data) {

        $scope.resetMap();

        $scope.points = [];
        $scope.readyToSave = false;

        $state.go('app.history');
    });

}]);
ctrl.controller('TrackViewController', ['$rootScope', '$scope', '$state', '$stateParams', '$ionicPopup', '$translate', '$timeout', 'TrackStorage', 'SettingsService', 'track', function ($rootScope, $scope, $state, $stateParams, $ionicPopup, $translate, $timeout, TrackStorage, SettingsService, track) {

    //track data has already been resolved in the route
    $scope.track = track;

    //human readable track duration
    $scope.formattedDuration = TrackStorage.formatDuration($scope.track.duration);

    //points list, as required by Polyline
    $scope.points = TrackStorage.getPolylinePoints($scope.track.points);

    //map scale ratio, see app.js
    $rootScope.mapScreenScale = 1;

    function initMap(points, mapTypeId) {
        $rootScope.map = new google.maps.Map(document.getElementById('map'), {
            zoom: 15,
            center: (points.length > 3) ? points[Math.ceil(points.length/2)] : points[0],
            mapTypeId: mapTypeId
        });

        // Define a symbol using SVG path notation, with an opacity of 1.
        var lineSymbol = {
            path: google.maps.SymbolPath.CIRCLE,
            strokeOpacity: 1,
            strokeWeight: 2,
            scale: 4,
            strokeColor: "#990000",
            fillColor: '#ffffff',
            fillOpacity: 1
        };

        // Create the polyline, passing the symbol in the 'icons' property.
        // Give the line an opacity of 0.
        // Repeat the symbol at intervals of 20 pixels to create the dashed effect.
        new google.maps.Polyline({
            path: points,
            strokeOpacity: 0,
            icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '20px'
                }],
            map: $rootScope.map
        });
    };

    $timeout(function(){
       initMap($scope.points, 'terrain'); 
    });
    

    //Confirmation dialog in case the user clicks on the delete button
    $scope.confirmDelete = function () {
        var confirmPopup = $ionicPopup.confirm({
            title: $translate.instant("dialog.confirm"),
            template: $translate.instant("dialog.track.confirm"),
            cancelText: $translate.instant("common.cancel"),
            cancelType: 'button-positive',
            okText: $translate.instant("common.yes"),
            okType: 'button-default'
        });

        confirmPopup.then(function (res) {
            if (res) {
                TrackStorage.delete($scope.track);
                $state.go('app.history');
            }
        });
    };
}]);