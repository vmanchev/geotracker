var geoApp = angular.module('toxic.geotracker', ['ionic', 'toxic.geotracker.controllers', 'ngCordova', 'pascalprecht.translate', 'nvd3'])

        .run(['$ionicPlatform', '$rootScope', '$timeout', '$translate', 'SettingsService', function ($ionicPlatform, $rootScope, $timeout, $translate, SettingsService) {
            $ionicPlatform.ready(function () {
                // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
                // for form inputs)
                if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
                    cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
                    cordova.plugins.Keyboard.disableScroll(true);

                }
                if (window.StatusBar) {
                    // org.apache.cordova.statusbar required
                    StatusBar.styleDefault();
                }

                $rootScope.settings = SettingsService.get();
                $translate.use($rootScope.settings.locale.id);

                $rootScope.$on('settings-changed', function () {
                    $rootScope.settings = SettingsService.get();
                    $translate.use($rootScope.settings.locale.id);
                });
                
                

                // Find matches
                var mql = window.matchMedia("(orientation: portrait)");

                // If there are matches, we're in portrait
                if (mql.matches) {
                    // Portrait orientation
                } else {
                    // Landscape orientation
                }

                // Add a media query change listener
                mql.addListener(function (m) {
                    if (m.matches) {
                        /**
                         * Changed to portrait
                         * 
                         * This is the app default orientation. Google Map should 
                         * be displayed with its initial height.
                         */
                        if (google) {
                            $timeout(function () {
                                angular.element(document.getElementById('map')).css('height', '200px');
                                google.maps.event.trigger($rootScope.map, 'resize');
                            });
                        }
                    } else {
                        /**
                         * Changed to landscape
                         * 
                         * Change Google Map container height by using the device 
                         * screen height and mapScreenScale, which is defined on 
                         * per controller basis. 
                         */
                        if (google) {
                            $timeout(function () {
                                angular.element(document.getElementById('map')).css('height', (screen.height * $rootScope.mapScreenScale) + 'px');
                                google.maps.event.trigger($rootScope.map, 'resize');
                            });
                        }
                    }
                });
            });
        }])
        .provider('settingsService', function settingsServiceProvider() {
            this.$get = function () {
                return new SettingsService();
            };
            return this;
        })
        .config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {
            $stateProvider

                    .state('app', {
                        url: '/app',
                        abstract: true,
                        templateUrl: 'templates/menu.html',
                        controller: 'AppCtrl'
                    })

                    .state('app.track', {
                        url: '/track',
                        cache: false,
                        resolve: {
                            requiredMapType: ['SettingsService', function (SettingsService) {
                                return SettingsService.get().mapType.id;
                            }]
                        },
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track.html',
                                controller: 'TrackController'
                            }
                        }
                    })

                    .state('app.history', {
                        url: '/history',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/history.html',
                                controller: 'HistoryController'
                            }
                        }
                    })

                    .state('app.trackview', {
                        url: '/track/:trackId',
                        cache: false,
                        resolve: {
                            track: ['$stateParams', 'TrackStorage', function ($stateParams, TrackStorage) {
                                return TrackStorage.getById($stateParams.trackId);
                            }],
                            requiredMapType: ['SettingsService', function (SettingsService) {
                                return SettingsService.get().mapType.id;
                            }]
                        },
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track-view.html',
                                controller: 'TrackViewController'
                            }
                        }
                    })

                    .state('app.trackedit', {
                        url: '/track/edit/:trackId',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/track-edit.html',
                                controller: 'TrackEditController'
                            }
                        }
                    })

                    .state('app.settings', {
                        url: '/settings',
                        cache: false,
                        resolve: {
                            mapTypes: ['SettingsService', function (SettingsService) {
                                return SettingsService.getMapTypes();
                            }],
                            availableLanguages: ['I18nService', function (I18nService) {
                                return I18nService.getAvailableLanguages();
                            }],
                            settings: ['SettingsService', function (SettingsService) {
                                return SettingsService.get();
                            }]
                        },
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/settings.html',
                                controller: 'SettingsController'
                            }
                        }
                    })
                    .state('app.about', {
                        url: '/about',
                        cache: false,
                        views: {
                            'menuContent': {
                                templateUrl: 'templates/about.html',
                                controller: 'AboutController'
                            }
                        }
                    });

            // if none of the above states are matched, use this as the fallback
            $urlRouterProvider.otherwise('/app/track');
        }])

        .config(['$translateProvider', function ($translateProvider) {
            $translateProvider.translations('en', TRANSLATIONS.en);
            $translateProvider.translations('bg', TRANSLATIONS.bg);

            $translateProvider.useSanitizeValueStrategy('escape');

            //we are not able to use the SettingsService at this point
            //hint: custom SettingsService provider?
            var settings = JSON.parse(localStorage.getItem('settings'));

            var locale = (!_.isEmpty(settings)) ? settings.locale : config.defaults.locale

            $translateProvider.preferredLanguage(locale.id);
        }])
        .filter('mapsUrl', ['$sce', function ($sce) {
            return function (apikey) {
                if (_.isEmpty(apikey)) {
                    return $sce.trustAsResourceUrl(config.maps.js);
                } else {
                    return $sce.trustAsResourceUrl(config.maps.js + '?key=' + apikey);
                }
            };
        }]);

var ctrl = angular.module('toxic.geotracker.controllers', []);
config = {
    maps: {
        js: 'https://maps.googleapis.com/maps/api/js',
        types: {
            js: 'settings.map.type.js',
            native: 'settings.map.type.native',
        }
    },
    defaults: {
      locale: {
          id: 'en',
          name: 'English'
      },
      mapType: 'native',
      apikey : 'AIzaSyAFqZ9Fs3e9PK0YpfOom-Ewi_gh4qV0eqc'
    }
};
var TRANSLATIONS = {
    "en": {
        "name" : "English",
        
        "nav.menu": "Menu",
        "nav.home": "Home",
        "nav.history": "History",
        "nav.settings" : "Settings",
        "nav.about" : "About",
        "nav.edit" : "Edit",
        
        "track.startTime" : "Start",
        "track.endTime" : "End",
        "track.duration" : "Duration",
        "track.start": "Start new track",
        "track.stop": "Stop",
        "track.save": "Save",
        "track.title" : "Track title",
        "track.notes" : "Track notes",
        "track.point_no": "Point #{{ id }}",
        "track.longitude": "Longitude",
        "track.latitude": "Latitude",
        "track.altitude": "Altitude",
        "track.direction": "Heading",
        "track.speed": "Speed, km/h",
        "track.average_speed": "Avg. speed, km/h",
        "track.displacement" : "Displacement, meters",
        "track.details": "Details",
        "track.delete" : "Delete",
        "track.edit" : "Edit",
        
        
        "settings.language" : "Language",
        "settings.maptypes" : "Map type",
        "settings.map.type.js" : "JavaScript",
        "settings.map.type.native" : "Native",
        "settings.apikey" : "Google API Key",
        
        "dialog.confirm" : "Confirm",
        "dialog.track.confirm" : "Are you sure you want to delete this track?",
        
        "common.yes" : "Yes",
        "common.no" : "No",
        "common.cancel" : "Cancel",
        "common.na" : "N/A",
        
        "time.year" : "y",
        "time.month" : "mo",
        "time.day" : "d",
        "time.hour" : "h",
        "time.minute" : "m",
        "time.second" : "s",
        
        "about.googleMapsLegal" : "Google Maps Legal Notice"
    },
    "bg": {
        "name" : "Български",
        
        "nav.menu": "Меню",
        "nav.home": "Начало",
        "nav.history": "История",
        "nav.settings" : "Настройки",
        "nav.about" : "Информация",
        "nav.edit" : "Редактирай",
        
        "track.startTime" : "Начало",
        "track.endTime" : "Край",
        "track.duration" : "Време",        
        "track.start": "Нов маршрут",
        "track.stop": "Стоп",
        "track.save": "Запази",
        "track.title" : "Име на маршрута",
        "track.notes" : "Бележки",        
        "track.point_no": "Точка №{{ id }}",
        "track.longitude": "Геогр. дълж.",
        "track.latitude": "Геогр. шир.",
        "track.altitude": "Надморска височина",
        "track.direction": "Посока",
        "track.speed": "Скорост, км/ч",
        "track.average_speed": "Средна скорост, км/ч",
        "track.displacement" : "Денивелация, метри",
        "track.details": "Детайли",
        "track.delete" : "Изтрий",
        "track.edit" : "Редактирай",
        
        "settings.language" : "Език",
        "settings.maptypes" : "Тип карти",
        "settings.map.type.js" : "JavaScript",
        "settings.map.type.native" : "Native",        
        "settings.apikey" : "Google API Key",
        
        "dialog.confirm" : "Потвърди",
        "dialog.track.confirm" : "Наистина ли искате да изтриете този запис?",
        
        "common.yes" : "Да",
        "common.no" : "Не",
        "common.cancel" : "Откажи",
        "common.na" : "неизвестно",
        
        "time.year" : "г.",
        "time.month" : "мес.",
        "time.day" : "дн.",
        "time.hour" : "ч.",
        "time.minute" : "мин.",
        "time.second" : "сек.",
        
        "about.googleMapsLegal" : "Лиценз на Google Maps"
    }
};
ctrl.controller('AboutController', ['$scope', '$ionicModal', '$ionicLoading', 'NativeMapsService', function ($scope, $ionicModal, $ionicLoading, NativeMapsService) {


    $scope.googleMapsLegal = function () {
        
        $ionicLoading.show();
        
        NativeMapsService.getLicenseInfo().then(function (data) {
            $scope.gmLicense = data;
            $scope.openModal();
            $ionicLoading.hide();
        });
    }


    $ionicModal.fromTemplateUrl('legal-modal.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function (modal) {
        $scope.modal = modal;
    });
    
    $scope.openModal = function () {
        $scope.modal.show();
    };
    $scope.closeModal = function () {
        $scope.modal.hide();
    };
    // Cleanup the modal when we're done with it!
    $scope.$on('$destroy', function () {
        $scope.modal.remove();
    });
    // Execute action on hide modal
    $scope.$on('modal.hidden', function () {
        // Execute action
    });
    // Execute action on remove modal
    $scope.$on('modal.removed', function () {
        // Execute action
    });


}]);
ctrl.controller('AppCtrl', function () {});
ctrl.controller('MenuController', ['$rootScope', '$scope', '$ionicSideMenuDelegate', function ($rootScope, $scope, $ionicSideMenuDelegate) {
    $scope.$watch(function () {
        return $ionicSideMenuDelegate.isOpenLeft();
    }, function (isOpen) {
        
        /**
         * When the side menu is closed, lets stay hidden!
         * 
         * Silly, but fixes a bug with the native maps plugin
         * 
         * @see https://forum.ionicframework.com/t/using-google-maps-cordova-plugin/4456/80
         * @see https://github.com/mapsplugin/cordova-plugin-googlemaps
         */
        $scope.hideLeft = (isOpen) ? false : true;
        
        /**
         * Events to describe the sidemenu state
         * 
         * Again, because of the way the native maps plugin works, we need to 
         * turn on and off the map area clickable propery. As the sidemenu 
         * does not emit any events, we are doing it here.
         * 
         * Whenever the map is used, subscribe to the "sidemenu:on" event to 
         * turn off the clickable property and to "sidemenu:off" to turn it on.
         * 
         * @see https://github.com/mapsplugin/cordova-plugin-googlemaps
         */
        var sideMenuEvent = (isOpen) ? "sidemenu:on" : "sidemenu:off";
        $rootScope.$emit(sideMenuEvent);

    });
}]);
ctrl.controller('SettingsController', ['$rootScope', '$scope', 'mapTypes', 'availableLanguages', 'settings', 'SettingsService', function ($rootScope, $scope, mapTypes, availableLanguages, settings, SettingsService) {

    //options for map type dropdown
    $scope.mapTypes = mapTypes;
    
    //options for languages dropdown
    $scope.availableLanguages = availableLanguages;
    
    //make the settings available in the view
    $scope.settings = settings;

    //Settings will be updated onblur or on page leave (which is blur again)
    $scope.$watch('settings', function(newSettings){
        SettingsService.set(newSettings);
        $rootScope.$emit('settings-changed');
    }, true);

}]);
geoApp.service('I18nService', ['$translate', function ($translate) {

    this.getAvailableLanguages = function () {

        var availableLanguages = [];

        //get available languages
        angular.forEach(TRANSLATIONS, function (keys, id) {
            availableLanguages.push({
                id: id,
                name: keys.name
            });
        });

        return availableLanguages;

    };

    this.setPreferedLanguage = function (selectedLanguage) {
        localStorage.setItem("locale", JSON.stringify(selectedLanguage));
        $translate.use(selectedLanguage.id)
    }

}])
geoApp.factory('JsMapsService', ['$rootScope', '$q', '$timeout', function ($rootScope, $q, $timeout) {

    var ms = {};

    ms.initMap = function (selector, options) {

        var deferred = $q.defer();

        var mapOptions = {
            zoom: (options.zoom) ? options.zoom : 15,
            mapTypeId: google.maps.MapTypeId.ROADMAP
        };

        //@bug a bit of inconsistency
        if(options && options.point){
            if(options.point.lat && options.point.lng){ //view track
                mapOptions.center = {lat: options.point.lat, lng: options.point.lng};
            }else if(options.point.latitude && options.point.longitude){    //new track
                mapOptions.center = {lat: options.point.latitude, lng: options.point.longitude};
            }            
        }

        $timeout(function () {
            deferred.resolve(
                    new google.maps.Map(document.getElementById(selector), mapOptions)
                    );
        });

        return deferred.promise;
    };


    // Function that return a LatLng Object to Map
    ms.setPosition = function (lat, lng) {
        return new google.maps.LatLng(lat, lng);
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps 
     * 
     * Use this method when the app is compiled with the native maps plugin. 
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ms.getPolylinePoints = function (points) {

        var filtered = [];

        angular.forEach(points, function (point) {
            this.push(ms.setPosition(point.coords.latitude, point.coords.longitude));
        }, filtered);

        return filtered;
    };

    /**
     * Add marker to the map
     * 
     * Map will also get cetered at the marker position
     * 
     * @param {object} map Source map
     * @param {float} lat Marker latitude
     * @param {float} lng Marker longitude
     * @returns {object} Updated map
     */
    ms.addMarker = function (map, lat, lng) {
        var marker = new google.maps.Marker({
            position: ms.setPosition(lat, lng)
        });

        marker.setMap(map);
        map.setCenter(marker.getPosition());

        return map;
    };

    /**
     * Removes a map from DOM
     */
    ms.remove = function (map, selector) {
        //Find the map DOM element
        var mapElement = document.getElementById(selector);

        //remove the html code
        mapElement.innerHTML = '';

        //remove the inline style
        mapElement.removeAttribute("style");

        //reset our internal map reference
        map = null;

        return map;
    };

    /**
     * Add polyline
     * 
     * For the initial version, a lot of options are hardcoded. These could 
     * easily goes to the configuration file.
     * 
     * @param {object} map Source map
     * @param {array} points Array of points
     * @returns {map} Updated map
     */
    ms.addPolyline = function (map, points) {

        // Define a symbol using SVG path notation, with an opacity of 1.
        var lineSymbol = {
            path: google.maps.SymbolPath.CIRCLE,
            strokeOpacity: 1,
            strokeWeight: 2,
            scale: 4,
            strokeColor: "#990000",
            fillColor: '#ffffff',
            fillOpacity: 1
        };

        // Create the polyline, passing the symbol in the 'icons' property.
        // Give the line an opacity of 0.
        // Repeat the symbol at intervals of 20 pixels to create the dashed effect.
        new google.maps.Polyline({
            path: points,
            strokeOpacity: 0,
            icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '20px'
                }],
            map: map
        });

        return map;
    }


    return ms;

}]);
geoApp.factory('NativeMapsService', ['$rootScope', '$q', function ($rootScope, $q) {

    var ms = {};

    ms.initMap = function (selector, options) {

        var deferred = $q.defer();

        // Getting the map selector in DOM
        var map_container = document.getElementById(selector);

        //@bug a bit of inconsistency
        if (options && options.point) {
            if (options.point.lat && options.point.lng) { //view track
                options.latLng = ms.setPosition(options.point.lat, options.point.lng);
            } else if (options.point.latitude && options.point.longitude) {    //new track
                options.latLng = ms.setPosition(options.point.latitude, options.point.longitude);
            }

            delete options.point;
        }

        if (_.isUndefined(options.zoom)) {
            options.zoom = 10;
        }

        // Invoking Map using Google Map SDK v2 by dubcanada
        var map = plugin.google.maps.Map.getMap(map_container, {
            camera: options
        });

        //@see MenuController
        $rootScope.$on('sidemenu:on', function () {
            map.setClickable(false);
        });

        //@see MenuController
        $rootScope.$on('sidemenu:off', function () {
            map.setClickable(true);
        });

        // Capturing event when Map load are ready.
        map.addEventListener(plugin.google.maps.event.MAP_READY, function (map) {
            deferred.resolve(map);
        });

        return deferred.promise;
    };


    // Function that return a LatLng Object to Map
    ms.setPosition = function (lat, lng) {
        return new plugin.google.maps.LatLng(lat, lng);
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps 
     * 
     * Use this method when the app is compiled with the native maps plugin. 
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ms.getPolylinePoints = function (points) {

        var filtered = [];

        angular.forEach(points, function (point) {
            this.push(ms.setPosition(point.coords.latitude, point.coords.longitude));
        }, filtered);

        return filtered;
    };

    /**
     * Add marker to the map
     * 
     * Map will also get cetered at the marker position
     * 
     * @param {object} map Source map
     * @param {float} lat Marker latitude
     * @param {float} lng Marker longitude
     * @returns {object} Updated map
     */
    ms.addMarker = function (map, lat, lng) {

        var position = ms.setPosition(lat, lng);

        map.addMarker({
            'position': position,
            'icon': {
                'url': 'www/img/marker.png',
                size: {
                    width: 10,
                    height: 10
                }
            }
        });

        map.setCenter(position);

        return map;
    };

    /**
     * Removes a map from DOM
     */
    ms.remove = function (map) {

        map.remove();

        //reset our internal map reference
        map = null;

        return map;
    };

    /**
     * Add polyline
     * 
     * For the initial version, a lot of options are hardcoded. These could 
     * easily goes to the configuration file.
     * 
     * @param {object} map Source map
     * @param {array} points Array of points
     * @returns {map} Updated map
     */
    ms.addPolyline = function (map, points) {

        map.addPolyline({
            points: points,
            color: '#990000',
            width: 5
        });

        return map;
    };

    ms.getLicenseInfo = function () {

        var deferred = $q.defer();

        plugin.google.maps.Map.getLicenseInfo(function(v1, v2){
            deferred.resolve(v1 || v2);
        });
        
        return deferred.promise;
    };

    return ms;

}]);
geoApp.service('SettingsService', ['$translate', 'I18nService', function ($translate, I18nService) {

    /**
     * Get app settings
     * 
     * If there are no settings in the local storage (e.g. the app is started 
     * for the first time), set the default settings and make them available.
     * 
     * @returns {object}
     */
    this.get = function () {
        
        var settings = JSON.parse(localStorage.getItem('settings'));

        if(_.isEmpty(settings)){
            settings = this.setDefaults();
        }
        
        return settings;
    };

    /**
     * Set/updates the app settings
     * 
     * @param {object} data Empty properties will be skipped
     */
    this.set = function (data) {
        var data = _.omitBy(data, function (value) {
            return _.isEmpty(value);
        });

        localStorage.setItem("settings", JSON.stringify(data));
    }

    /**
     * Set default app settings
     * 
     * @returns {settings_L1.setDefaults.defaults}
     */
    this.setDefaults = function () {

        var defaults = {
            locale: config.defaults.locale,
            mapType: _.filter(this.getMapTypes(), {id: config.defaults.mapType}).shift(),
            apikey: config.defaults.apikey
        };

        this.set(defaults);
        
        return defaults;
    }

    /**
     * Map types
     * 
     * Retrives an array of the available map types in config.json file. It will 
     * be presented in the app settings to define which map type to be in used - 
     * Javascript or native.
     * 
     * @returns {Array}
     */
    this.getMapTypes = function () {

        var mapTypes = [];

        angular.forEach(config.maps.types, function (name, id) {

            this.push({
                id: id,
                name: $translate.instant(name)
            });
        }, mapTypes);

        return mapTypes;

    };

}]);
geoApp.factory('TrackStorage', ['$translate', function ($translate) {

    /**
     * Key name to store the tracks under in localStorage
     * @type String
     */
    var key = 'tracks';

    /**
     * Service object
     * 
     * The service object holds all the public methods
     * 
     * @type object
     */
    var ts = {};

    /**
     * Get all the tracks
     * 
     * @returns {Array} In  case there are no tracks, an empty array will be returned
     */
    ts.getAll = function () {

        var serializedTracks = _get();

        return (_.isNull(serializedTracks)) ? [] : JSON.parse(serializedTracks);
    };

    /**
     * Get a track by id
     * 
     * @param {integer} id
     * @returns {object}
     */
    ts.getById = function (id) {
        return _.find(ts.getAll(), {trackId: parseInt(id)});
    };

    /**
     * Save track
     * 
     * Add a new track or update an existing one. 
     * 
     * If there are no tracks in the storage (this is the first one), add the new 
     * track to the empty tracks array. 
     * 
     * If it is a new track, it will be added to the beginning of the tracks array. 
     * This will help us later to avoid sorting, when we need to show the list 
     * of tracks - newer tracks will automatically appear at the top :)
     * 
     * In case there are some tracks in the storage, try to lookup the track by 
     * its trackId property. If the passed track object does not exists in the 
     * tracks array, add the new one at the end. If the passed track object does 
     * exists at the tracks array, find its index and replace the value.
     * 
     * If the index parameter was set, we will replace the track object under 
     * that index.
     * 
     * @param {object} track Track object to save
     * @param {Integer|undefined} idx Index to update
     */
    ts.save = function (track) {

        var tracks = ts.getAll();

        var query = {trackId: track.trackId};

        var isExisting = (_.find(tracks, query)) ? true : false;

        if (_.isEmpty(tracks) || (!_.isEmpty(tracks) && !isExisting)) {
            //empty tracks array or a new track
            tracks.unshift(track);
        }else if (!_.isEmpty(tracks) && isExisting) {
            //existing track to be updated
            var idx = _.findIndex(tracks, query);
            tracks[idx] = track;
        }

        _set(tracks);
    };

    /**
     * Delete the selected track
     * 
     * Get all tracks and identify the one to be deleted by the trackId property, 
     * then update the storage.
     * 
     * @param {object} track
     */
    ts.delete = function (track) {

        var tracks = ts.getAll();

        _.remove(tracks, function (t) {
            return t.trackId === track.trackId;
        });

        _set(tracks);
    };

    ts.formatDuration = function (duration) {
        return moment.duration(duration, "seconds")
                .format("Y [" + $translate.instant('time.year') + "], M [" + $translate.instant('time.month') + "], D [" + $translate.instant('time.day') + "], h [" + $translate.instant('time.hour') + "], m [" + $translate.instant('time.minute') + "], s [" + $translate.instant('time.second') + "]");
    };

    ts.formatPointTime = function (duration) {
        return moment.duration(duration, "seconds")
                .format("h:mm:ss", {trim: false});
    };

    /**
     * Get track points
     * 
     * Loop over the track points and transform it to the format, required 
     * by Google Maps for Polyline
     * 
     * @returns {array} Array of objects with two keys - lat and lng
     */
    ts.getPolylinePoints = function (points) {

        var filtered = [];

        angular.forEach(points, function (point) {
            this.push({lat: point.coords.latitude, lng: point.coords.longitude});
        }, filtered);

        return filtered;
    };

    ts.getChartData = function (track, key) {

        var chartData = {key: key, values: []};

        angular.forEach(track.points, function (point) {
            
            var tmpKey = parseFloat(point.coords[key]);
            
            if(!_.isUndefined(point.timestamp) && !isNaN(tmpKey) && key === 'speed' && tmpKey >= 0){
                
            }else if (!_.isUndefined(point.timestamp) && !isNaN(tmpKey)) {
                this.push({x:point.timestamp, y:tmpKey});
            }
            
        }, chartData.values);

        return chartData;
    };
    
    ts.getAverageSpeed = function(track){
        
        var data = [];

        angular.forEach(track.points, function (point) {

            if (!_.isUndefined(point.coords.speed) && point.coords.speed > 0) {
                this.push(parseFloat(point.coords.speed));
            }
        }, data);

        return (_.isEmpty(data)) ? 0 : _.mean(data).toFixed(2);
        
    };
    
    ts.getDisplacement = function(track){
        
        var data = [];

        angular.forEach(track.points, function (point) {
            //temp var to avoid  altitude casting twice
            var tmpAltitude = parseFloat(point.coords.altitude);
            
            if (!isNaN(tmpAltitude)) {
                this.push(tmpAltitude);
            }
        }, data);

        return (_.isEmpty(data)) ? 0 : (_.max(data) - _.min(data)).toFixed(2);
        
    }
    

    /**
     * Write to local storage
     * 
     * Private method to write data to the local storage under the service key.
     * 
     * @param {object} value Object to be serialized and written as JSON string
     */
    var _set = function (value) {
        localStorage.setItem(key, JSON.stringify(value));
    };

    /**
     * Read from local storage
     * 
     * Read the data from local storage under the service key
     * 
     * @returns {DOMString}
     */
    var _get = function () {
        return localStorage.getItem(key);
    };

    return ts;

}]);
ctrl.controller('TrackEditController', ['$scope', '$state', '$stateParams', 'TrackStorage', function ($scope, $state, $stateParams, TrackStorage) {

    $scope.track = TrackStorage.getById($stateParams.trackId);

    $scope.updateTrack = function () {
        TrackStorage.save($scope.track);
        $state.go('app.trackview', $stateParams);
    }

}]);
ctrl.controller('HistoryController', ['$scope', 'TrackStorage', function ($scope, TrackStorage) {
    $scope.items = TrackStorage.getAll();
}]);
ctrl.controller('TrackController', ['$rootScope', '$scope', '$state', '$ionicLoading', '$cordovaGeolocation', 'JsMapsService', 'NativeMapsService', 'TrackStorage', 'requiredMapType', function ($rootScope, $scope, $state, $ionicLoading, $cordovaGeolocation, JsMapsService, NativeMapsService, TrackStorage, requiredMapType) {

    var mapSelector = 'map';

    var mapService = (requiredMapType === 'js') ? JsMapsService : NativeMapsService;

    //has tracking been started or not
    $scope.isTracking = false;
    $scope.readyToSave = false;
    $scope.initPoint = {};

    //map scale ratio, see app.js
    $rootScope.mapScreenScale = 0.8;

    /**
     * Start a new track
     * 
     * When the "Start" button is clicked, we will first try to get the current 
     * position and in case of success, will broadcast the "tracking:started" 
     * event along with the location data.
     * 
     * @todo In case of an error, show a proper message.
     * @returns {undefined}
     */
    $scope.startTracking = function () {

        $scope.startTime = new Date();

        $ionicLoading.show();

        $cordovaGeolocation.getCurrentPosition({
            timeout: 30000,
            enableHighAccuracy: true,
            maximumAge: 10000
        }).then(function (locationData) {
            $scope.$broadcast('tracking:started', locationData);
        }, $scope.positionError)
                .finally(function () {
                    $ionicLoading.hide();
                });
    }

    /**
     * Track success callback
     * 
     * Will be called on position change. Actions to be performed: 
     * 1. Collect the position data
     * 2. Call the watchTracking function, if the watcher hasn't been started yet.
     * 3. Call the updateMap function to add a new marker.
     * 
     * @param {object} data
     * @returns {undefined} Object with two keys - timestamp and coords. Coords 
     * itself is an object with two keys - latitiude and longitude. 
     * 
     * @example 
     * {
     *  timestamp: data.timestamp,
     *  coords: {
     *      latitude: data.coords.latitude,
     *      longitude: data.coords.longitude
     *  }
     * }
     */
    $scope.positionSuccess = function (data) {

        //add the new point to the array of points
        $scope.points.push(data);

        //if watcher hasn't been started yet, start it now
        if (!$scope.trackWatch) {
            $scope.watchTracking();
        }

        //show position on the map
        $scope.updateMap(data.coords.latitude, data.coords.longitude);
    }

    //error callback
    $scope.positionError = function (error) {
        console.log("error", error)
    }

    /**
     * Position change track
     * 
     * Will track new position change every 3 seconds
     * 
     * @returns {undefined}
     */
    $scope.watchTracking = function () {

        $scope.trackWatch = $cordovaGeolocation.watchPosition({
            timeout: 30000,
            frequency: 10000,
            enableHighAccuracy: true// may cause errors if true
        });

        $scope.trackWatch.then(null, function (error) {

            $scope.positionError(error);

            //restarting the watcher
            $scope.trackWatch.clearWatch();
            $scope.watchTracking();

        }, function (data) {
            $scope.positionSuccess(data);
        });

    }

    //display position on the map
    $scope.updateMap = function (latitude, longitude) {
        $scope.map = mapService.addMarker(
                $scope.map,
                latitude,
                longitude
                );
    }

    /**
     * Stop tracking
     * 
     * 1. Save the current track in the history
     * 2. Stop the watcher
     * 3. Clear the points array
     * 
     * @returns {undefined}
     */
    $scope.stopTracking = function () {
        $scope.endTime = new Date();
        $scope.isTracking = false;
        $scope.trackWatch.clearWatch();

        $scope.$broadcast('tracking:stopped');
    }

    /**
     * Save the current track to the app history
     * 
     * We will call it from the view.
     * 
     * @returns {undefined}
     */
    $scope.saveHistory = function () {

        var track = {
            trackId: $scope.trackId,
            points: $scope.points,
            info: _.omitBy($scope.trackInfo, function (value) {
                return _.isEmpty(value);
            }),
            startTime: $scope.startTime,
            endTime: $scope.endTime,
            duration: moment($scope.endTime).diff(moment($scope.startTime), "seconds")
        };

        TrackStorage.save(track);

        $scope.$broadcast('tracking:saved');
    }

    /**
     * Listener for the tracking:started event
     * 
     * When this event is captured, it means the tracking has been started 
     * successfully and we have the current position. Actions to be performed: 
     * 1. Call the MapService to initialize the map. 
     * 2. Set the initial states of all supporting variables. 
     * 3. Call the positionSuccess function.
     */
    $scope.$on('tracking:started', function (event, data) {

        $scope.initPoint = data;

        mapService.initMap(mapSelector, {
            point: $scope.initPoint.coords,
            zoom: 16
        }).then(function (map) {

            $scope.map = map;

            $scope.isTracking = true;

            //container for geo location points
            $scope.points = [];

            //has watcher been started or not
            $scope.trackWatch = null;

            $scope.trackId = (new Date()).getTime();

            $scope.trackInfo = {
                title: null,
                notes: null
            };

            $scope.positionSuccess($scope.initPoint);

            $scope.initPoint = {};
        });

    });

    /**
     * Stop button listener
     * 
     * When the "Stop" button is clicked, it means the user is at their destination 
     * and are ready to save the track. Actions to be performed:
     * 
     * 1. Hide the start/stop buttons at the top.
     * 2. Allow the user to optionally add title and description.
     * 3. show the save button
     * 
     * Please note, at this point the information is not saved! It's still in 
     * the current scope.
     */
    $scope.$on('tracking:stopped', function () {
        $scope.readyToSave = true;
    });

    /**
     * Save button listener
     * 
     * The track information has already been saved in the data store. Now do 
     * the chore: 
     * 1. Destroy the map
     * 2. Reset the points array to an empty one.
     * 3. Switch some flags.
     * 4. Navigate to the History page
     */
    $scope.$on('tracking:saved', function (event, data) {

        $scope.map = mapService.remove($scope.map, mapSelector);

        $scope.points = [];
        $scope.readyToSave = false;

        $state.go('app.history');
    });

}]);
ctrl.controller('TrackViewController', ['$rootScope', '$scope', '$state', '$ionicPopup', '$translate', '$timeout', 'JsMapsService', 'NativeMapsService', 'TrackStorage', 'track', 'requiredMapType', function ($rootScope, $scope, $state, $ionicPopup, $translate, $timeout, JsMapsService, NativeMapsService, TrackStorage, track, requiredMapType) {

    var mapSelector = 'map';

    var mapService = (requiredMapType === 'js') ? JsMapsService : NativeMapsService;

    //track data has already been resolved in the route
    $scope.track = track;

    //human readable track duration
    $scope.formattedDuration = TrackStorage.formatDuration($scope.track.duration);

    //points list, as required by Polyline
    var points = TrackStorage.getPolylinePoints($scope.track.points);

    var altitudePoints = TrackStorage.getChartData($scope.track, 'altitude');

    var speedPoints = TrackStorage.getChartData($scope.track, 'speed');

    $scope.averageSpeed = TrackStorage.getAverageSpeed($scope.track);
    if ($scope.averageSpeed === 0) {
        $scope.averageSpeed = $translate.instant('common.na');
    }

    $scope.displacement = TrackStorage.getDisplacement($scope.track);
    if ($scope.displacement === 0) {
        $scope.displacement = $translate.instant('common.na');
    }

    //map scale ratio, see app.js
    $rootScope.mapScreenScale = 1;

    $timeout(function () {
        $scope.map = mapService.initMap(mapSelector, {
            point: (points.length > 3) ? points[Math.ceil(points.length / 2)] : points[0],
            zoom: 16
        }).then(function (map) {

            $scope.map = map;

            $scope.map = mapService.addPolyline($scope.map, points);

        });
    }, 1000);


    /* Chart options */
    $scope.altitudeChartOptions = {
        title: {
            enable: true,
            text: $translate.instant('track.altitude')
        },
        chart: {
            type: 'lineChart',
            height: 250,
            margin: {
                top: 20,
                right: 20,
                bottom: 30,
                left: 40
            },
            showControls: false,
            showLegend: false,
            useVoronoi: false,
            clipEdge: true,
            duration: 100,
            useInteractiveGuideline: true,
            interactiveLayer: {
                tooltip: {
                    contentGenerator: function (d) {

                        var html = "<ul>";

                        d.series.forEach(function (elem) {

                            var translatedKey = $translate.instant("track." + elem.key);

                            html += "<li style='padding: 5px; color:" + elem.color + "'>"
                                    + translatedKey + " : <b>" + elem.value + "</b></li>";
                        })
                        html += "</ul>"
                        return html;
                    }
                }
            },
            xAxis: {
                showMaxMin: false,
                tickFormat: function (d) {
                    return TrackStorage.formatPointTime((d - $scope.track.trackId) / 1000);
                }
            },
            yAxis: {
                showMaxMin: false,
                tickFormat: function (d) {
                    return d;
                }
            }
        }
    };

    $scope.speedChartOptions = angular.copy($scope.altitudeChartOptions);
    $scope.speedChartOptions.title.text = $translate.instant('track.speed');

    /* Chart data */
    $scope.altitudeChartData = [altitudePoints];
    $scope.speedChartData = [speedPoints];

    //Confirmation dialog in case the user clicks on the delete button
    $scope.confirmDelete = function () {
        var confirmPopup = $ionicPopup.confirm({
            title: $translate.instant("dialog.confirm"),
            template: $translate.instant("dialog.track.confirm"),
            cancelText: $translate.instant("common.cancel"),
            cancelType: 'button-positive',
            okText: $translate.instant("common.yes"),
            okType: 'button-default'
        });

        confirmPopup.then(function (res) {
            if (res) {
                TrackStorage.delete($scope.track);
                $state.go('app.history');
            }
        });
    };
}]);